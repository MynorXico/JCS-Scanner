// CUP spect_ification t_for a simple expression evaluator (no actions)
package php.scanner;


import java_cup.runtime.*;
import java.util.LinkedList;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.swing.text.BadLocationException;
// Opciones y Declaraciones



// Parser Code
parser code
{:
    public LinkedList<TError> TablaES = new LinkedList<TError>();
    public ManejadorScopes ms = new ManejadorScopes();

    public void syntax_error(Symbol s){
        String lexema = s.value.toString();
        int fila = s.right;
        int columna = s.left;

        try {
          Interfaz.getInterfaz().AddTextToJTextArea("Error Sintáctico. Lexema: "+lexema+"\tFila: " + (fila+1) + "\tColumna: "+ (columna+1)+"\n");
        } catch (BadLocationException ex) {
            System.out.println("Error escribiendo");
            Logger.getLogger(parser.class.getName()).log(Level.SEVERE, null, ex);
        }
    }
    public void unrecovered_syntax_error(Symbol s) throws java.lang.Exception{
        String lexema = s.value.toString();
        int fila = s.right;
        int columna = s.left;
        
        try {
          Interfaz.getInterfaz().AddTextToJTextArea("Error Sintáctico. Lexema: "+lexema+"\tFila: " + (fila+1) + "\tColumna: "+ (columna+1)+"\n");
        } catch (BadLocationException ex) {
            System.out.println("Error escribiendo");
            Logger.getLogger(parser.class.getName()).log(Level.SEVERE, null, ex);
        }
    }

:}  

action code {: 
    ManejadorScopes ms = new ManejadorScopes();
:}



terminal  String  minus, cmpop, logop,ident,pyc,t_int,t_double,t_bool, t_string, bolCnst,strConst,brackets,t_void,prnthss_A,prnthss_C,comma,clase,t_implements,t_interface,
                  t_if, t_else,t_for,t_while,t_return,t_break,print,t_this,brackets_A,brackets_C,neg,malloc,readInteger,
                  ReadLine,dot,dblConst,t_null,t_newArr,getByte,setByte, equals, curly_A, curly_C, extend, t_new, plus, times, divide, mod;
terminal String intCnst;


/* No terminales usados en la seccion gramatical. */
non terminal String     VariableList, Program, Decl, VariableDecl,FunctionDecl,ClassDecl, DeclStar, InterfaceDecl,Variable,Type,Formals,StmtBlock,Field,
                        ExtendsIdentOptional,ImplementsIdentPlusCommaOptional,Prototype,Stmt,IfStmt,WhileStmt,ForStmt,BreakStmt,ReturnStmt,PrintStmt,FieldStar,
                        VariableDeclStar,StmtStar,LValue,Constant,Call,Actuals,LibCall,
                         PrototypeStar, ExprOptional,  IdentList, ExprList;
non terminal String Expr;


precedence left equals;
precedence left logop;
precedence nonassoc cmpop;
precedence left plus, minus;
precedence left times, divide, mod;
precedence nonassoc neg;
precedence nonassoc brackets_A, dot;
precedence nonassoc t_else;

start with Program;



//GRAMATICA   
    Program ::= Decl DeclStar
    ;
    Decl ::= VariableDecl|
             FunctionDecl|
             ClassDecl|
             InterfaceDecl|
             error pyc|
             error curly_C
    ;
    DeclStar ::= |DeclStar Decl ;
    
    VariableDecl ::= Variable pyc
    ;
    Variable ::= Type:t ident:i {: ms.AgregarSimbolo(i, new oSymbol(i, t, "Variable", "")); :}
    ;
    Type ::= t_int|
             t_double|
             t_bool|
             t_string|
             ident|
             Type brackets
    ;
    FunctionDecl ::= Type:t ident:i {: ms.AgregarSimbolo(i, new oSymbol(i, t, "Function", null)); :}	prnthss_A {: ms.NuevoScope(); :} Formals prnthss_C StmtBlock {: ms.FinalizaScope();:}|
                    t_void:t ident:i {: ms.AgregarSimbolo(i, new oSymbol(i, t, "Function", null)); :}  prnthss_A {: ms.NuevoScope(); :} Formals prnthss_C StmtBlock {: ms.FinalizaScope(); :}
    ;
    Formals ::= VariableList|;

    VariableList    ::= Variable|
                        VariableList comma Variable
    ;
    

    ClassDecl ::= clase:t ident:i {: ms.AgregarSimbolo(i, new oSymbol(i, t, "Class", null)); :} ExtendsIdentOptional ImplementsIdentPlusCommaOptional curly_A {: ms.NuevoScope(); :} FieldStar {: ms.FinalizaScope(); :} curly_C		
    ;
    FieldStar ::= FieldStar Field |
    ;
    ExtendsIdentOptional ::= extend ident |
    ;
    ImplementsIdentPlusCommaOptional ::= t_implements IdentList |
    ;

    IdentList   ::= ident|
                    IdentList comma ident;


    Field::= VariableDecl|
             FunctionDecl
    ;
    InterfaceDecl ::= t_interface:t ident:i {: ms.AgregarSimbolo(i, new oSymbol(i, t, "Interface", null)); :} curly_A {: ms.NuevoScope(); :}PrototypeStar {: ms.FinalizaScope(); :} curly_C
    ;
    PrototypeStar ::= PrototypeStar Prototype |;
    Prototype ::= Type ident prnthss_A Formals prnthss_C pyc|
                  t_void ident prnthss_A Formals prnthss_C pyc
    ;
    Stmt ::= Expr pyc|
                pyc|
                    {: ms.NuevoScope(); :}IfStmt {: ms.FinalizaScope(); :}|
                    {: ms.NuevoScope(); :} WhileStmt {: ms.FinalizaScope(); :}|
                    {: ms.NuevoScope(); :} ForStmt {: ms.FinalizaScope(); :}|
                    BreakStmt|
                    ReturnStmt|
                    PrintStmt|
                    StmtBlock
    ;
    StmtBlock ::= curly_A VariableDeclStar StmtStar curly_C
    ;
    IfStmt ::=  t_if  prnthss_A Expr prnthss_C Stmt |t_if prnthss_A Expr prnthss_C  Stmt t_else Stmt
    ;

    
    VariableDeclStar ::=VariableDeclStar  VariableDecl |
    ;
    StmtStar ::=  Stmt StmtStar| 
    ;
    WhileStmt ::= t_while prnthss_A Expr prnthss_C Stmt										
    ;
    ForStmt ::= t_for prnthss_A ExprOptional pyc Expr pyc ExprOptional prnthss_C Stmt
    ;
    ReturnStmt ::= t_return ExprOptional pyc
    ;
    BreakStmt ::= t_break pyc
    ;
    PrintStmt ::= print prnthss_A ExprList prnthss_C pyc
    ;
    
    
    ExprOptional    ::= Expr| ;

    Expr ::= LValue equals Expr|
             ident|
             ident equals Expr|
             Constant:c {:RESULT = c;:}|
             LValue|
             t_this|
             Call|
             prnthss_A Expr prnthss_C|
             Expr: e1 plus Expr: e2 {: //RESULT = String.valueOf(Double.valueOf(e1) + Double.valueOf(e2));:}|
             Expr: e1 times Expr: e2 {: //RESULT = String.valueOf(Double.valueOf(e1) * Double.valueOf(e2));:}|
             Expr: e1 divide Expr: e2 {:// RESULT = String.valueOf(Double.valueOf(e1) / Double.valueOf(e2));:}|
             Expr: e1 mod Expr: e2 {: //RESULT = String.valueOf(Double.valueOf(e1) % Double.valueOf(e2));:}|
             Expr logop Expr|
             Expr cmpop Expr|
             Expr: e1 minus Expr: e2 {: //RESULT = String.valueOf(Double.valueOf(e1) - Double.valueOf(e2));:}|
             minus Expr|
             neg Expr|
             t_new prnthss_A ident prnthss_C|
             t_newArr prnthss_A Expr comma Type prnthss_C|
             readInteger prnthss_A prnthss_C|
             ReadLine prnthss_A prnthss_C|
             malloc prnthss_A Expr prnthss_C 
    ;
    LValue ::= Expr dot ident|
               Expr brackets_A Expr brackets_C
    ;
    Call ::= ident prnthss_A Actuals prnthss_C|
             Expr dot ident prnthss_A Actuals prnthss_C|
             Expr dot LibCall prnthss_A Actuals prnthss_C
    ;
    LibCall ::= getByte prnthss_A Expr prnthss_C|
                setByte prnthss_A Expr comma Expr prnthss_C
    ;
    Actuals ::= ExprList|
    ;

    ExprList    ::= Expr|
                    ExprList comma Expr;

    Constant ::= intCnst:i {:RESULT = i;:}|
                 dblConst|
                 bolCnst|
                 strConst|
                 t_null
    ;
    
