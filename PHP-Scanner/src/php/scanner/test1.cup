// CUP spect_ification t_for a simple expression evaluator (no actions)
package php.scanner;


import java_cup.runtime.*;
import java.util.LinkedList;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.swing.text.BadLocationException;
// Opciones y Declaraciones



// Parser Code
parser code
{:
    public LinkedList<TError> TablaES = new LinkedList<TError>();
    public ManejadorScopes ms = new ManejadorScopes();

    public void syntax_error(Symbol s){
        String lexema = s.value.toString();
        int fila = s.right;
        int columna = s.left;

        try {
          Interfaz.getInterfaz().AddTextToJTextArea("Error Sintáctico. Lexema: "+lexema+"\tFila: " + (fila+1) + "\tColumna: "+ (columna+1)+"\n");
        } catch (BadLocationException ex) {
            System.out.println("Error escribiendo");
            Logger.getLogger(parser.class.getName()).log(Level.SEVERE, null, ex);
        }
    }
    public void unrecovered_syntax_error(Symbol s) throws java.lang.Exception{
        String lexema = s.value.toString();
        int fila = s.right;
        int columna = s.left;
        
        try {
          Interfaz.getInterfaz().AddTextToJTextArea("Error Sintáctico. Lexema: "+lexema+"\tFila: " + (fila+1) + "\tColumna: "+ (columna+1)+"\n");
        } catch (BadLocationException ex) {
            System.out.println("Error escribiendo");
            Logger.getLogger(parser.class.getName()).log(Level.SEVERE, null, ex);
        }
    }

:}  

action code {: 
    ManejadorScopes ms = new ManejadorScopes();

    public boolean isNumber(String s){
        try{
            Double.valueOf(s);
            return true;
        }catch(Exception e){
            return false;
        }
    }
    
    public boolean isInteger(String s){
        if(isNumber(s) && !s.contains(".")){
            return true;
        }
        return false;
    }

    
    public boolean isBoolean(String s){
        return (s.equals("true") || s.equals("false"));
    }
:}



terminal  String  minus, cmpop, logop,ident,pyc,t_int,t_double,t_bool, t_string, bolCnst,strConst,brackets,t_void,prnthss_A,prnthss_C,comma,clase,t_implements,t_interface,
                  t_if, t_else,t_for,t_while,t_return,t_break,print,t_this,brackets_A,brackets_C,neg,malloc,readInteger,
                  ReadLine,dot,dblConst,t_null,t_newArr,getByte,setByte, equals, curly_A, curly_C, extend, t_new, plus, times, divide, mod;
terminal String intCnst;


/* No terminales usados en la seccion gramatical. */
non terminal String     VariableList, Program, Decl, VariableDecl,FunctionDecl,ClassDecl, DeclStar, InterfaceDecl,Variable,Type,Formals,StmtBlock,Field,
                        ExtendsIdentOptional,ImplementsIdentPlusCommaOptional,Prototype,Stmt,IfStmt,WhileStmt,ForStmt,BreakStmt,ReturnStmt,PrintStmt,FieldStar,
                        VariableDeclStar,StmtStar,LValue,Constant,Call,Actuals,LibCall,
                         PrototypeStar, ExprOptional,  IdentList, ExprList;
non terminal String Expr;


precedence left equals;
precedence left logop;
precedence nonassoc cmpop;
precedence left plus, minus;
precedence left times, divide, mod;
precedence nonassoc neg;
precedence nonassoc brackets_A, dot;
precedence nonassoc t_else;

start with Program;



//GRAMATICA   
    Program ::= Decl DeclStar
    ;
    Decl ::= VariableDecl|
             FunctionDecl|
             ClassDecl|
             InterfaceDecl|
             error pyc|
             error curly_C
    ;
    DeclStar ::= |DeclStar Decl ;
    
    VariableDecl ::= Variable pyc
    ;
    Variable ::= Type:t ident:i {: ms.AgregarSimbolo(i, new oSymbol(i, t, "Variable", null)); :}
    ;
    Type ::= t_int:t {: RESULT = t; :}|
             t_double:t {: RESULT = t; :}|
             t_bool:t {: RESULT = t; :}|
             t_string:t {: RESULT = t; :}|
             ident:t {: RESULT = t; :}|
             Type brackets
    ;
    FunctionDecl ::= Type:t ident:i {: ms.AgregarSimbolo(i, new oSymbol(i, t, "Function", null)); :}	prnthss_A {: ms.NuevoScope(); :} Formals prnthss_C StmtBlock {: ms.FinalizaScope();:}|
                    t_void:t ident:i {: ms.AgregarSimbolo(i, new oSymbol(i, t, "Function", null)); :}  prnthss_A {: ms.NuevoScope(); :} Formals prnthss_C StmtBlock {: ms.FinalizaScope(); :}
    ;
    Formals ::= VariableList|;

    VariableList    ::= Variable|
                        VariableList comma Variable
    ;
    

    ClassDecl ::= clase:t ident:i {: ms.AgregarSimbolo(i, new oSymbol(i, t, "Class", null)); :} ExtendsIdentOptional ImplementsIdentPlusCommaOptional curly_A {: ms.NuevoScope(); :} FieldStar {: ms.FinalizaScope(); :} curly_C		
    ;
    FieldStar ::= FieldStar Field |
    ;
    ExtendsIdentOptional ::= extend ident |
    ;
    ImplementsIdentPlusCommaOptional ::= t_implements IdentList |
    ;

    IdentList   ::= ident|
                    IdentList comma ident;


    Field::= VariableDecl|
             FunctionDecl
    ;
    InterfaceDecl ::= t_interface:t ident:i {: ms.AgregarSimbolo(i, new oSymbol(i, t, "Interface", null)); :} curly_A {: ms.NuevoScope(); :}PrototypeStar {: ms.FinalizaScope(); :} curly_C
    ;
    PrototypeStar ::= PrototypeStar Prototype |;
    Prototype ::= Type ident prnthss_A Formals prnthss_C pyc|
                  t_void ident prnthss_A Formals prnthss_C pyc
    ;
    Stmt ::= Expr pyc|
                pyc|
                    {: ms.NuevoScope(); :}IfStmt {: ms.FinalizaScope(); :}|
                    {: ms.NuevoScope(); :} WhileStmt {: ms.FinalizaScope(); :}|
                    {: ms.NuevoScope(); :} ForStmt {: ms.FinalizaScope(); :}|
                    BreakStmt|
                    ReturnStmt|
                    PrintStmt|
                    StmtBlock
    ;
    StmtBlock ::= curly_A VariableDeclStar StmtStar curly_C
    ;
    IfStmt ::=  t_if  prnthss_A Expr prnthss_C Stmt |t_if prnthss_A Expr prnthss_C  Stmt t_else Stmt
    ;

    
    VariableDeclStar ::=VariableDeclStar  VariableDecl |
    ;
    StmtStar ::=  Stmt StmtStar| 
    ;
    WhileStmt ::= t_while prnthss_A Expr prnthss_C Stmt										
    ;
    ForStmt ::= t_for prnthss_A ExprOptional pyc Expr pyc ExprOptional prnthss_C Stmt
    ;
    ReturnStmt ::= t_return ExprOptional pyc
    ;
    BreakStmt ::= t_break pyc
    ;
    PrintStmt ::= print prnthss_A ExprList prnthss_C pyc
    ;
    
    
    ExprOptional    ::= Expr| ;

    Expr ::= LValue equals Expr|
             ident: i {: 
                if(ms.GetSimbolo(i) != null){ // Existe
                    System.out.println("Se obtuvo correctamente el símbolo " + i);
                    RESULT = ms.GetSimbolo(i).Value;
                }else {
                    System.out.println("No existe el símbolo " + i + " en el ámbito actual. ");
                }
             :}|
             ident:i equals Expr: e {: 
                if(ms.GetSimbolo(i)==null){
                    System.out.println("El símbolo " + i + " no se encuentra en el ámbito actual.");
                }else if(e==null){
                    System.out.println("No se puede asignar el valor de null a la variable.");
                }else{
                    if((ms.GetSimbolo(i).DataType.compareTo("int") == 0 && !isInteger(e)) 
                            || (ms.GetSimbolo(i).DataType.compareTo("double") == 0 && !isNumber(e))
                            || (ms.GetSimbolo(i).DataType.compareTo("bool") == 0 && !isBoolean(e))){
                        System.out.println("El dato a asignar no es del mismo tipo que la variable");
                    } else{
                        System.out.println("Se asignó a " + i + " el valor de " + e);
                        ms.GetSimbolo(i).Value = e;
                    }
                    
                    
                }
            
             :}|
             Constant:c {:RESULT = c;:}|
             LValue|
             t_this|
             Call|
             prnthss_A Expr: e prnthss_C {:
                RESULT  = e;
             :}|
             Expr: e1 plus Expr: e2 {:
                if(e1 == null){
                    System.out.println("La variable " + e1 + " nunca fue asignada.");
                }else if (e2 == null){
                    System.out.println("La variable " + e2 + " nunca fue asignada.");
                }else if(ms.GetSimbolo(e1).DataType.equals("string") || ms.GetSimbolo(e1).DataType.equals("bool") || ms.GetSimbolo(e2).DataType.equals("string") || ms.GetSimbolo(e2).DataType.equals("bool") ){
                    System.out.println("Esta operación no está deinida para este tipo de dato.");
                }
                else{
                    RESULT = String.valueOf(Double.valueOf(e1) + Double.valueOf(e2));
                }
            :}|
            Expr: e1 times Expr: e2 {:
                if(e1 == null){
                    System.out.println("La variable " + e1 + " nunca fue asignada.");
                }else if (e2 == null){
                    System.out.println("La variable " + e2 + " nunca fue asignada.");
                }else if(ms.GetSimbolo(e1).DataType.equals("string") || ms.GetSimbolo(e1).DataType.equals("bool") || ms.GetSimbolo(e2).DataType.equals("string") || ms.GetSimbolo(e2).DataType.equals("bool") ){
                    System.out.println("Esta operación no está deinida para este tipo de dato.");
                }
                else{
                    RESULT = String.valueOf(Double.valueOf(e1) * Double.valueOf(e2));
                }
            :}|
            Expr: e1 divide Expr: e2 {:
                if(e1 == null){
                    System.out.println("La variable " + e1 + " nunca fue asignada.");
                }else if (e2 == null){
                    System.out.println("La variable " + e2 + " nunca fue asignada.");
                }else if(ms.GetSimbolo(e1).DataType.equals("string") || ms.GetSimbolo(e1).DataType.equals("bool") || ms.GetSimbolo(e2).DataType.equals("string") || ms.GetSimbolo(e2).DataType.equals("bool") ){
                    System.out.println("Esta operación no está deinida para este tipo de dato.");
                }
                else{
                    RESULT = String.valueOf(Double.valueOf(e1) / Double.valueOf(e2));
                }
            :}|

            Expr: e1 mod Expr: e2 {:
               if(e1 == null){
                    System.out.println("La variable " + e1 + " nunca fue asignada.");
                }else if (e2 == null){
                    System.out.println("La variable " + e2 + " nunca fue asignada.");
                }else if(ms.GetSimbolo(e1).DataType.equals("string") || ms.GetSimbolo(e1).DataType.equals("bool") || ms.GetSimbolo(e2).DataType.equals("string") || ms.GetSimbolo(e2).DataType.equals("bool") ){
                    System.out.println("Esta operación no está deinida para este tipo de dato.");
                }
                else{
                    RESULT = String.valueOf(Double.valueOf(e1) % Double.valueOf(e2));
                }
            :}|

            Expr logop Expr|
            Expr: e1 cmpop:c Expr: e2{: 
                if(e1 == null){
                    System.out.println("La variable " + e1 + " nunca fue asignada.");
                }else if(e2==null){
                    System.out.println("La variable " + e2 + " nunca fue asignada.");
                }
                else if(c.equals("==")){
                    RESULT = String.valueOf(e1.equals(e2));
                } else if(c.equals("<")){
                    RESULT = String.valueOf(Double.valueOf(e1) < Double.valueOf(e2));
                } else if(c.equals(">")){
                    RESULT = String.valueOf(Double.valueOf(e1) > Double.valueOf(e2));
                 }else if(c.equals("<=")){
                    RESULT = String.valueOf(Double.valueOf(e1) <= Double.valueOf(e2));
                } else if(c.equals("!=")){
                    RESULT = String.valueOf(!e1.equals(e2));
                } else if (c.equals(">=")){
                    RESULT = String.valueOf(Double.valueOf(e1) >= Double.valueOf(e2));
                }
             :}|
             Expr: e1 minus Expr: e2 {: 
                 if(e1 == null){
                    System.out.println("La variable " + e1 + " nunca fue asignada.");
                }else if (e2 == null){
                    System.out.println("La variable " + e2 + " nunca fue asignada.");
                }else if(ms.GetSimbolo(e1).DataType.equals("string") || ms.GetSimbolo(e1).DataType.equals("bool") || ms.GetSimbolo(e2).DataType.equals("string") || ms.GetSimbolo(e2).DataType.equals("bool") ){
                    System.out.println("Esta operación no está deinida para este tipo de dato.");
                }
                else{
                    RESULT = String.valueOf(Double.valueOf(e1) - Double.valueOf(e2));
                }
             :}|
             minus Expr|
             neg Expr:e {: 
                if(e==null){
                    System.out.println("La variable " + e + " nunca fue asignada.");
                } else{
                    System.out.println("Operación de negación !("+e+") = "+ !(Boolean.valueOf(e)));
                    RESULT = String.valueOf(!(Boolean.valueOf(e)));
                }
             :}|
             t_new prnthss_A ident:i prnthss_C {: 
                
            :}|
             t_newArr prnthss_A Expr comma Type prnthss_C|
             readInteger prnthss_A prnthss_C|
             ReadLine prnthss_A prnthss_C|
             malloc prnthss_A Expr prnthss_C 
    ;
    LValue ::= Expr dot ident|
               Expr brackets_A Expr brackets_C
    ;
    Call ::= ident prnthss_A Actuals prnthss_C {:
                // Código para llamada a función
            :}|
             Expr dot ident prnthss_A Actuals prnthss_C {:
                // Código para llamada a función
             :}|
             Expr dot LibCall prnthss_A Actuals prnthss_C
                // Código para llamada a función
    ;
    LibCall ::= getByte prnthss_A Expr prnthss_C|
                setByte prnthss_A Expr comma Expr prnthss_C
    ;
    Actuals ::= ExprList|
    ;

    ExprList    ::= Expr|
                    ExprList comma Expr;

    Constant ::= intCnst:i {:RESULT = i;:}|
                 dblConst: i {: RESULT = i; :}|
                 bolCnst: i {: RESULT = i; :}|
                 strConst: i {: RESULT = i; :}|
                 t_null : i {: RESULT = i; :}
    ;
    
